<!doctype html>
<html lang="en">

<head>
    <script src="https://d3js.org/d3.v4.js"></script>
</head>

<body>
    <img src="https://www.countryflags.io/be/flat/64.png">
    <input type="range" min="4" max="10" value="4" id="xvalue">
    <div id="boxPlotContainer"></div>
    <script>

        function formatNumber(number) {
            return Number.parseFloat(number).toFixed(2);
        }

        function drawBoxPlot() {
            // set the dimensions and margins of the graph
            var margin = { top: 10, right: 30, bottom: 30, left: 40 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#boxPlotContainer")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // create a tooltip
            var Tooltip = d3.select("#boxPlotContainer")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px")

            // Three function that change the tooltip when user hover / move / leave a cell
            var mouseover = function (d) {
                Tooltip
                    .style("opacity", 1)
            }
            var mousemove = function (d) {
                let text = "Data:<br>" +
                    `min: ${formatNumber(d.value.min)}<br>` +
                    `max: ${formatNumber(d.value.max)}<br>` +
                    `q1: ${formatNumber(d.value.q1)}<br>` +
                    `median: ${formatNumber(d.value.median)}<br>` +
                    `q3: ${formatNumber(d.value.q3)}<br>`;
                Tooltip
                    .html(text)
                    .style("position", "absolute")
                    .style("left", `${d3.mouse(this)[0] + 70}px`)
                    .style("top", `${d3.mouse(this)[1]}px`);
            }
            var mouseleave = function (d) {
                Tooltip
                    .style("opacity", 0)
            }

            // Read the data and compute summary statistics for each specie
            d3.csv("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/iris.csv", function (data) {


                console.log("Data:")
                console.log(data)

                // Compute quartiles, median, inter quantile range min and max --> these info are then used to draw the box.
                var sumstat = d3.nest() // nest function allows to group the calculation per level of a factor
                    .key(function (d) { return d.Species; })
                    .rollup(function (d) {
                        q1 = d3.quantile(d.map(function (g) { return g.Sepal_Length; }).sort(d3.ascending), .25)
                        median = d3.quantile(d.map(function (g) { return g.Sepal_Length; }).sort(d3.ascending), .5)
                        q3 = d3.quantile(d.map(function (g) { return g.Sepal_Length; }).sort(d3.ascending), .75)
                        interQuantileRange = q3 - q1
                        min = q1 - 1.5 * interQuantileRange
                        max = q3 + 1.5 * interQuantileRange
                        return ({ q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max })
                    })
                    .entries(data)

                // Show the X scale
                var x = d3.scaleBand()
                    .range([0, width])
                    .domain(["setosa", "versicolor", "virginica"])
                    .paddingInner(1)
                    .paddingOuter(.5)
                svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x))

                // Show the Y scale
                var y = d3.scaleLinear()
                    .domain([3, 9])
                    .range([height, 0])
                svg.append("g").call(d3.axisLeft(y))

                // Show the main vertical line
                svg
                    .selectAll("vertLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("x1", function (d) { return (x(d.key)) })
                    .attr("x2", function (d) { return (x(d.key)) })
                    .attr("y1", function (d) { return (y(d.value.min)) })
                    .attr("y2", function (d) { return (y(d.value.max)) })
                    .attr("stroke", "black")
                    .style("width", 40)
                    .on("mouseover", mouseover)
                    .on("mousemove", mousemove)
                    .on("mouseleave", mouseleave)

                // rectangle for the main box
                var boxWidth = 50 //------> [width/SIZE(domene)] minus margine lijevo desno 
                svg
                    .selectAll("boxes")
                    .data(sumstat)
                    .enter()
                    .append("rect")
                    .attr("x", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("y", function (d) { return (y(d.value.q3)) })
                    .attr("height", function (d) { return (y(d.value.q1) - y(d.value.q3)) })
                    .attr("width", boxWidth)
                    .attr("stroke", "black")
                    .style("fill", "#69b3a2")
                    .on("mouseover", mouseover)
                    .on("mousemove", mousemove)
                    .on("mouseleave", mouseleave)

                // Show the median
                svg
                    .selectAll("medianLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("x1", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("x2", function (d) { return (x(d.key) + boxWidth / 2) })
                    .attr("y1", function (d) { return (y(d.value.median)) })
                    .attr("y2", function (d) { return (y(d.value.median)) })
                    .attr("stroke", "black")
                    .style("width", 80)
                    .on("mouseover", mouseover)
                    .on("mousemove", mousemove)
                    .on("mouseleave", mouseleave)
            })
        }

        function drawAreaChart() {
            // set the dimensions and margins of the graph
            var margin = { top: 10, right: 30, bottom: 30, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#boxPlotContainer")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            //Read the data
            d3.csv("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/5_OneCatSevNumOrdered.csv", function (data) {

                // group the data: one array for each value of the X axis.
                var sumstat = d3.nest()
                    .key(function (d) { return d.year; })
                    .entries(data);

                // Stack the data: each group will be represented on top of each other
                var mygroups = ["Helen", "Amanda", "Ashley"] // list of group names
                var mygroup = [1, 2, 3] // list of group names
                var stackedData = d3.stack()
                    .keys(mygroup)
                    .value(function (d, key) {
                        return d.values[key].n
                    })
                    (sumstat)

                // Add X axis --> it is a date format
                var x = d3.scaleLinear()
                    .domain(d3.extent(data, function (d) { return d.year; }))
                    .range([0, width]);
                svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x).ticks(5));

                // Add Y axis
                var y = d3.scaleLinear()
                    .domain([0, d3.max(data, function (d) { return +d.n; }) * 1.2])
                    .range([height, 0]);
                svg.append("g")
                    .call(d3.axisLeft(y));

                // color palette
                var color = d3.scaleOrdinal()
                    .domain(mygroups)
                    .range(['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'])

                // Show the areas
                svg
                    .selectAll("mylayers")
                    .data(stackedData)
                    .enter()
                    .append("path")
                    .style("fill", function (d) { name = mygroups[d.key - 1]; return color(name); })
                    .attr("d", d3.area()
                        .x(function (d, i) { return x(d.data.key); })
                        .y0(function (d) { return y(d[0]); })
                        .y1(function (d) { return y(d[1]); })
                    )

            })
        }

        function drawRadarChart(data, ) {
            let testData = [{ "x": 10, "y": 50 },
            { "x": 20, "y": 20 },
            { "x": 50, "y": 10 },
            { "x": 30, "y": 30 }];
            // set the dimensions and margins of the graph
            var margin = { top: 10, right: 30, bottom: 30, left: 60 },
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            let center = {
                x: width / 2,
                y: height / 2
            }
            let numberOfIntervals = 5
            let numberOfTicks = 3;

            // append the svg object to the body of the page
            var svg = d3.select("#boxPlotContainer")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
            let angle = d3
                .scaleLinear()
                .range([0, 360])
                .domain([0, numberOfIntervals]);
            console.log("DATA")
            svg.selectAll("radialLines")
                .data([...Array(numberOfIntervals).keys()])
                .enter()
                .append("line")
                .style("stroke", "black")
                .attr("x1", center.x)
                .attr("y1", center.y)
                .attr("x2", center.x)
                .attr("y2", 0)
                .attr("transform", (d) => `rotate(${angle(d)}, ${center.x}, ${center.y})`);

            for (let i = 0; i < numberOfTicks; i++) {
                let distance = ((i + 1) / numberOfTicks) * center.y - 30;
                svg
                    .selectAll(`radialLines_${i}`)
                    .data([[...Array(numberOfIntervals).keys()]])
                    .enter()
                    .append("polygon")
                    .style("fill", "none")
                    .style("stroke", "black")
                    .attr("points", function (d) {
                        return d.map(function (d) {
                            let angle2 = ((2 * Math.PI / numberOfIntervals) * d) + Math.PI / 2;
                            console.log(`ANGLE: ${angle2}, DISTANCE: ${distance}, d: ${d}`)
                            let x1 = center.x + Math.cos(angle2) * distance
                            console.log(`X1: ${x1}`)
                            return [x1, center.y - Math.sin(angle2) * distance].join(",");
                        }).join(" ");
                    });








                /*let d = ((i + 1) / numberOfTicks) * center.y;
                let alfa = (2 * Math.PI / numberOfIntervals);
                let alfaS = 360 / numberOfIntervals;
                let gamma = 90 - ((180 - alfaS) / 2);
                let b = 2 * d * Math.sin(alfa / 2);
                svg.selectAll(`radialLines_${i}`)
                    .data([...Array(numberOfIntervals).keys()])
                    .enter()
                    .append("line")
                    .style("stroke", "black")
                    .attr("x1", center.x)
                    .attr("y1", center.y - d)
                    .attr("x2", center.x + b)
                    .attr("y2", center.y - d)
                    .attr("transform", (data) => `rotate(${gamma}, ${center.x}, ${center.y - d}) translate(0, 100)`)*/
                //.attr("transform", (data) => ``);
            }

            /*svg
                .selectAll("testLayers")
                .data([testData])
                .enter()
                .append("polygon")
                .style("fill", "green")
                .attr("points", function (d) {
                    return d.map(function (d) {
                        return [x(d.x), y(d.y)].join(",");
                    }).join(" ");
                });*/

            //draw radar graph axis
            //number of axis is number of 
            //maybe scaleLinear(0, 2*PI)
            //domain (0, COUNT[])
            //draw polygons for each state numOfStatesOnGraph
        }

        drawBoxPlot()

        drawAreaChart()

        drawRadarChart()

        function debounce(func, wait = 100, immediate) {
            var timeout;
            return function () {
                var context = this, args = arguments;
                var later = function () {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        };

        d3.csv("data_projection.csv", (data) => {
            console.log("SUCCESS!!")
            console.log(data)
            d3.select("#xvalue").on("mouseup", function () {
                onValueChanged(this.value, data);
            });
        }
        )

        function onValueChanged(value, data) {
            console.log("The value is " + value);
            drawRadarChart(transformDataForRadar(data, value), value)
        }
        /*
        maps [
            {
                AGE: "1 year"
        Flag and Footnotes: ""
        GEO: "Austria"
        PROJECTION: "Baseline projections"
        SEX: "Males"
        TIME: "2020"
        UNIT: "Person"
        Value: "43,295"
        }
        ]
        */
        /*returns {
            value: [123, 123,12332,3232,1543,546],
            max: 32123
        }*/
        function transformDataForRadar(data, numOfRanges, geo = "Croatia", year = 2019) {
            //numOfRanges = 3 splits [0-33, 33-66, 66-100+]
            let values = []
            let ranges = [...Array(parseInt(numOfRanges)).keys()].map(num => {
                let borders = [(num * 100 / numOfRanges), (num * 100 / numOfRanges) + (100 / numOfRanges)];
                let people = data.filter(value => {
                    let age = parseInt(value.AGE.split(" ")[0])
                    return age >= borders[0] && age < borders[1] && value.GEO.startsWith(geo) && parseInt(value.TIME) == year
                }).map(entry => parseInt(entry.Value.replace(',', '')))
                let numberOfPeople = people.reduce((a, b) => a + b, 0)
                values.push(numberOfPeople)
            })
            let returnObj = {
                values: values,
                max: Math.max(...values)
            }
            return returnObj
        }

        /*
         // Build color scale
            var myColor = d3.scaleSequential()
            .interpolator(d3.interpolateInferno)
            .domain([1,100])
        */

    </script>
</body>